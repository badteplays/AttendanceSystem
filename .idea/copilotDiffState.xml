<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/attendancesystem/TeacherDashboardFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/attendancesystem/TeacherDashboardFragment.kt" />
              <option name="originalContent" value="package com.example.attendancesystem&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.attendancesystem.utils.ProfilePictureManager&#10;import com.example.attendancesystem.models.TeacherAttendanceItem&#10;import com.example.attendancesystem.models.StudentItem&#10;import com.example.attendancesystem.adapters.TeacherAttendanceAdapter&#10;import com.example.attendancesystem.adapters.StudentSelectionAdapter&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import android.app.AlertDialog&#10;import android.widget.ArrayAdapter&#10;import android.widget.AutoCompleteTextView&#10;import android.widget.RadioButton&#10;import com.google.firebase.firestore.ListenerRegistration&#10;import androidx.lifecycle.lifecycleScope&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;class TeacherDashboardFragment : Fragment() {&#10;    companion object {&#10;        private const val RECENT_ATTENDANCE_LIMIT = 100&#10;        private const val TAG = &quot;TeacherDashboard&quot;&#10;    }&#10;    private lateinit var imageProfilePic: ImageView&#10;    private lateinit var textInitials: TextView&#10;    private lateinit var textName: TextView&#10;    private lateinit var textDepartment: TextView&#10;    private lateinit var textQrExpiry: TextView&#10;    private lateinit var buttonShowQr: Button&#10;    private lateinit var buttonRenewQr: Button&#10;    private lateinit var buttonRefreshAttendance: Button&#10;    private lateinit var buttonManualAdd: Button&#10;    private lateinit var buttonAnalytics: Button&#10;    private lateinit var buttonEndClass: Button&#10;    private lateinit var attendanceRecyclerView: RecyclerView&#10;    private lateinit var textAttendanceCount: TextView&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;    private var attendanceListener: ListenerRegistration? = null&#10;    private var listeningScheduleId: String? = null&#10;    private var listeningSubject: String? = null&#10;    private var currentScheduleEndTime: String? = null&#10;    private val classEndHandler = android.os.Handler(android.os.Looper.getMainLooper())&#10;    private var classEndRunnable: Runnable? = null&#10;    private var attendanceAdapter: TeacherAttendanceAdapter? = null&#10;    private val attendanceList = mutableListOf&lt;TeacherAttendanceItem&gt;()&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        return inflater.inflate(R.layout.fragment_teacher_dashboard, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        initializeViews(view)&#10;        setupClickListeners()&#10;        loadUserData()&#10;        loadRecentAttendance()&#10;    }&#10;    &#10;    private fun initializeViews(view: View) {&#10;        imageProfilePic = view.findViewById(R.id.imageProfilePic)&#10;        textInitials = view.findViewById(R.id.textInitials)&#10;        textName = view.findViewById(R.id.textName)&#10;        textDepartment = view.findViewById(R.id.textDepartment)&#10;        textQrExpiry = view.findViewById(R.id.textQrExpiry)&#10;        buttonShowQr = view.findViewById(R.id.buttonShowQr)&#10;        buttonRenewQr = view.findViewById(R.id.buttonRenewQr)&#10;        buttonRefreshAttendance = view.findViewById(R.id.buttonRefreshAttendance)&#10;        buttonManualAdd = view.findViewById(R.id.buttonManualAdd)&#10;        buttonAnalytics = view.findViewById(R.id.buttonAnalytics)&#10;        buttonEndClass = view.findViewById(R.id.buttonEndClass)&#10;        attendanceRecyclerView = view.findViewById(R.id.attendanceRecyclerView)&#10;        textAttendanceCount = view.findViewById(R.id.textAttendanceCount)&#10;        &#10;        // Setup RecyclerView with adapter&#10;        attendanceRecyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        attendanceAdapter = TeacherAttendanceAdapter(attendanceList) { item -&gt;&#10;            confirmAndRemoveAttendance(item)&#10;        }&#10;        attendanceRecyclerView.adapter = attendanceAdapter&#10;    }&#10;    &#10;    private fun setupClickListeners() {&#10;        buttonShowQr.setOnClickListener {&#10;            // Show QR: Open QR activity to show existing QR (or create if none exists)&#10;            showQRCode(forceNew = false)&#10;        }&#10;        &#10;        buttonRenewQr.setOnClickListener {&#10;            // Renew QR: Force delete old sessions and create fresh QR code&#10;            showQRCode(forceNew = true)&#10;        }&#10;        &#10;        buttonRefreshAttendance.setOnClickListener {&#10;            // Force remove existing listener and reload fresh&#10;            attendanceListener?.remove()&#10;            attendanceListener = null&#10;            listeningScheduleId = null&#10;            listeningSubject = null&#10;            loadRecentAttendance()&#10;        }&#10;        &#10;        buttonManualAdd.setOnClickListener {&#10;            showManualAddDialog()&#10;        }&#10;        &#10;        buttonAnalytics.setOnClickListener {&#10;            val intent = Intent(requireContext(), TeacherMainActivity::class.java)&#10;            intent.putExtra(&quot;open&quot;, &quot;analytics&quot;)&#10;            startActivity(intent)&#10;        }&#10;        &#10;        buttonEndClass.setOnClickListener {&#10;            confirmEndClass()&#10;        }&#10;    }&#10;    &#10;    private fun loadUserData() {&#10;        val currentUser = auth.currentUser&#10;        currentUser?.let {&#10;            db.collection(&quot;users&quot;).document(it.uid)&#10;                .addSnapshotListener { snapshot, _ -&gt;&#10;                    if (snapshot != null &amp;&amp; snapshot.exists()) {&#10;                        val name = snapshot.getString(&quot;name&quot;) ?: &quot;Teacher&quot;&#10;                        val department = snapshot.getString(&quot;department&quot;) ?: &quot;Department&quot;&#10;                        textName.text = name&#10;                        textDepartment.text = department&#10;                        ProfilePictureManager.getInstance().loadProfilePicture(requireContext(), imageProfilePic, textInitials, name, &quot;TC&quot;)&#10;                    }&#10;                }&#10;        }&#10;    }&#10;    &#10;    private fun showQRCode(forceNew: Boolean = false) {&#10;        val currentUser = auth.currentUser ?: run {&#10;            Toast.makeText(requireContext(), &quot;Not signed in&quot;, Toast.LENGTH_SHORT).show(); return&#10;        }&#10;&#10;        val currentDay = getCurrentDayOfWeek()&#10;        val nowMinutes = getCurrentTimeInMinutes()&#10;&#10;        db.collection(&quot;schedules&quot;)&#10;            .whereEqualTo(&quot;teacherId&quot;, currentUser.uid)&#10;            .whereEqualTo(&quot;day&quot;, currentDay)&#10;            .get()&#10;            .addOnSuccessListener { scheduleDocs -&gt;&#10;                val todays = scheduleDocs.documents&#10;                val match = todays.firstOrNull { doc -&gt;&#10;                    val start = doc.getString(&quot;startTime&quot;) ?: &quot;&quot;&#10;                    val end = doc.getString(&quot;endTime&quot;) ?: &quot;&quot;&#10;                    isNowWithinRange(nowMinutes, start, end)&#10;                }&#10;&#10;                fun launchFor(doc: com.google.firebase.firestore.DocumentSnapshot) {&#10;                    val intent = android.content.Intent(requireContext(), QRActivity::class.java).apply {&#10;                        putExtra(&quot;scheduleId&quot;, doc.id)&#10;                        putExtra(&quot;subject&quot;, doc.getString(&quot;subject&quot;) ?: &quot;Attendance&quot;)&#10;                        putExtra(&quot;section&quot;, doc.getString(&quot;section&quot;) ?: &quot;&quot;)&#10;                        putExtra(&quot;forceNew&quot;, forceNew) // Pass flag to force new QR&#10;                    }&#10;                    startActivity(intent)&#10;                }&#10;&#10;                if (match != null) {&#10;                    launchFor(match)&#10;                } else {&#10;                    // No current class — find next upcoming today and inform the teacher&#10;                    val next = todays&#10;                        .mapNotNull { doc -&gt;&#10;                            val start = doc.getString(&quot;startTime&quot;) ?: return@mapNotNull null&#10;                            val startMin = parseTimeToMinutes24(start) ?: return@mapNotNull null&#10;                            Pair(startMin, doc)&#10;                        }&#10;                        .filter { it.first &gt; nowMinutes }&#10;                        .minByOrNull { it.first }&#10;                        ?.second&#10;&#10;                    if (next != null) {&#10;                        val subj = next.getString(&quot;subject&quot;) ?: &quot;&quot;&#10;                        val sec = next.getString(&quot;section&quot;) ?: &quot;&quot;&#10;                        val start = next.getString(&quot;startTime&quot;) ?: &quot;&quot;&#10;                        Toast.makeText(requireContext(), &quot;No current class. Next: $subj ($sec) at $start&quot;, Toast.LENGTH_LONG).show()&#10;                    } else if (todays.isNotEmpty()) {&#10;                        Toast.makeText(requireContext(), &quot;No more classes today&quot;, Toast.LENGTH_LONG).show()&#10;                    } else {&#10;                        Toast.makeText(requireContext(), &quot;No schedules found for today&quot;, Toast.LENGTH_LONG).show()&#10;                    }&#10;                }&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Toast.makeText(requireContext(), &quot;Error loading schedule: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;    }&#10;    &#10;    private fun renewQRCode() {&#10;        // Simply re-open QRActivity to generate a fresh QR for the current class&#10;        showQRCode()&#10;    }&#10;    &#10;    private fun loadRecentAttendance() {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser != null) {&#10;            val currentDay = getCurrentDayOfWeek()&#10;            val nowMinutes = getCurrentTimeInMinutes()&#10;            // Find today's schedules and determine the current class with minute precision&#10;            db.collection(&quot;schedules&quot;)&#10;                .whereEqualTo(&quot;teacherId&quot;, currentUser.uid)&#10;                .whereEqualTo(&quot;day&quot;, currentDay)&#10;                .get()&#10;                .addOnSuccessListener { scheduleDocs -&gt;&#10;                    if (scheduleDocs.isEmpty()) {&#10;                        // No schedule for today — show recent attendance fallback&#10;                        textQrExpiry.text = &quot;No classes scheduled for today&quot;&#10;                        loadRecentAttendanceFallback()&#10;                        return@addOnSuccessListener&#10;                    }&#10;                    &#10;                    // Find the current class based on precise minutes (supports crossing midnight)&#10;                    val currentSchedule = scheduleDocs.documents.firstOrNull { doc -&gt;&#10;                        val startTime = doc.getString(&quot;startTime&quot;) ?: &quot;&quot;&#10;                        val endTime = doc.getString(&quot;endTime&quot;) ?: &quot;&quot;&#10;                        isNowWithinRange(nowMinutes, startTime, endTime)&#10;                    }&#10;                    &#10;                    if (currentSchedule != null) {&#10;                        val scheduleId = currentSchedule.id&#10;                        val subject = currentSchedule.getString(&quot;subject&quot;) ?: &quot;&quot;&#10;                        val section = currentSchedule.getString(&quot;section&quot;) ?: &quot;&quot;&#10;                        &#10;                        // Update QR status&#10;                        textQrExpiry.text = &quot;Current Class: $subject ($section)&quot;&#10;                        // Start realtime listener for this class&#10;                        startAttendanceListener(scheduleId, subject)&#10;                    } else {&#10;                        // No current class — archive any old attendance from ended classes today&#10;                        val endedSchedules = scheduleDocs.documents&#10;                            .filter { doc -&gt;&#10;                                val endTime = doc.getString(&quot;endTime&quot;) ?: return@filter false&#10;                                val endMin = parseTimeToMinutes24(endTime) ?: return@filter false&#10;                                // Check if class has ended&#10;                                if (endMin &lt; parseTimeToMinutes24(doc.getString(&quot;startTime&quot;) ?: &quot;00:00&quot;) ?: 0) {&#10;                                    // Class crosses midnight - check if we're past the end time in the new day&#10;                                    nowMinutes &gt; endMin &amp;&amp; nowMinutes &lt; 720 // Before noon means new day&#10;                                } else {&#10;                                    nowMinutes &gt; endMin&#10;                                }&#10;                            }&#10;                        &#10;                        // Archive attendance from all ended classes today&#10;                        if (endedSchedules.isNotEmpty()) {&#10;                            archiveEndedClassesAttendance(endedSchedules)&#10;                        }&#10;                        &#10;                        // Show next class info&#10;                        val nextSchedule = scheduleDocs.documents&#10;                            .mapNotNull { doc -&gt;&#10;                                val startTime = doc.getString(&quot;startTime&quot;) ?: return@mapNotNull null&#10;                                val startMin = parseTimeToMinutes24(startTime) ?: return@mapNotNull null&#10;                                Pair(startMin, doc)&#10;                            }&#10;                            .filter { it.first &gt; nowMinutes }&#10;                            .minByOrNull { it.first }&#10;                            ?.second&#10;                        &#10;                        if (nextSchedule != null) {&#10;                            val subject = nextSchedule.getString(&quot;subject&quot;) ?: &quot;&quot;&#10;                            val section = nextSchedule.getString(&quot;section&quot;) ?: &quot;&quot;&#10;                            val startTime = nextSchedule.getString(&quot;startTime&quot;) ?: &quot;&quot;&#10;                            textQrExpiry.text = &quot;Next Class: $subject ($section) at $startTime&quot;&#10;                        } else {&#10;                            textQrExpiry.text = &quot;No classes scheduled for today&quot;&#10;                        }&#10;                        &#10;                        // Stop any existing listener since no current class&#10;                        attendanceListener?.remove()&#10;                        attendanceListener = null&#10;                        listeningScheduleId = null&#10;                        listeningSubject = null&#10;                        buttonEndClass.visibility = View.GONE&#10;                        loadRecentAttendanceFallback()&#10;                    }&#10;                }&#10;                .addOnFailureListener { e -&gt;&#10;                    Toast.makeText(requireContext(), &quot;Error loading schedule: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;        }&#10;    }&#10;&#10;    private fun startAttendanceListener(scheduleId: String, subject: String) {&#10;        val currentUser = auth.currentUser ?: return&#10;        if (listeningScheduleId == scheduleId &amp;&amp; listeningSubject == subject &amp;&amp; attendanceListener != null) {&#10;            return&#10;        }&#10;        attendanceListener?.remove()&#10;        listeningScheduleId = scheduleId&#10;        listeningSubject = subject&#10;        &#10;        // Get the class start and end time for filtering and auto-archiving&#10;        db.collection(&quot;schedules&quot;).document(scheduleId)&#10;            .get()&#10;            .addOnSuccessListener { scheduleDoc -&gt;&#10;                val startTime = scheduleDoc.getString(&quot;startTime&quot;) ?: &quot;00:00&quot;&#10;                val endTime = scheduleDoc.getString(&quot;endTime&quot;) ?: &quot;23:59&quot;&#10;                &#10;                // Store end time for scheduling&#10;                currentScheduleEndTime = endTime&#10;                &#10;                // Show the &quot;End Class&quot; button for current class&#10;                buttonEndClass.visibility = View.VISIBLE&#10;                &#10;                // Schedule auto-archive when class ends&#10;                scheduleAutoArchiveAtClassEnd(endTime)&#10;                &#10;                // Calculate today's class start timestamp&#10;                val calendar = java.util.Calendar.getInstance()&#10;                val (startHour, startMin) = parseTime24(startTime)&#10;                calendar.set(java.util.Calendar.HOUR_OF_DAY, startHour)&#10;                calendar.set(java.util.Calendar.MINUTE, startMin)&#10;                calendar.set(java.util.Calendar.SECOND, 0)&#10;                calendar.set(java.util.Calendar.MILLISECOND, 0)&#10;                val classStartTimestamp = com.google.firebase.Timestamp(calendar.time)&#10;                &#10;                // Listen for attendance from this class session only (after class start time)&#10;                // Exclude archived records by only querying the attendance collection (not archived_attendance)&#10;                android.util.Log.d(TAG, &quot;=== TEACHER QUERYING ATTENDANCE ===&quot;)&#10;                android.util.Log.d(TAG, &quot;teacherId: ${currentUser.uid}&quot;)&#10;                android.util.Log.d(TAG, &quot;scheduleId: $scheduleId&quot;)&#10;                android.util.Log.d(TAG, &quot;subject: $subject&quot;)&#10;                android.util.Log.d(TAG, &quot;timestamp &gt;= $classStartTimestamp&quot;)&#10;                attendanceListener = db.collection(&quot;attendance&quot;)&#10;                    .whereEqualTo(&quot;teacherId&quot;, currentUser.uid)&#10;                    .whereEqualTo(&quot;scheduleId&quot;, scheduleId)&#10;                    .whereEqualTo(&quot;subject&quot;, subject)&#10;                    .whereGreaterThanOrEqualTo(&quot;timestamp&quot;, classStartTimestamp)&#10;                    .addSnapshotListener { snapshot, e -&gt;&#10;                        if (e != null) {&#10;                            android.util.Log.e(TAG, &quot;Attendance listen failed: ${e.message}&quot;, e)&#10;                            Toast.makeText(requireContext(), &quot;Attendance listen failed: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                            return@addSnapshotListener&#10;                        }&#10;                        &#10;                        // Sort by timestamp in memory to avoid composite index requirement&#10;                        val newAttendanceList = snapshot?.documents&#10;                            ?.sortedByDescending { doc -&gt; &#10;                                doc.getTimestamp(&quot;timestamp&quot;)?.seconds ?: 0L &#10;                            }&#10;                            ?.map { doc -&gt;&#10;                                TeacherAttendanceItem(&#10;                                    documentId = doc.id,&#10;                                    studentName = doc.getString(&quot;studentName&quot;) ?: &quot;Unknown Student&quot;,&#10;                                    timeTaken = formatTimestamp(doc.getTimestamp(&quot;timestamp&quot;)),&#10;                                    section = doc.getString(&quot;section&quot;) ?: &quot;&quot;,&#10;                                    status = doc.getString(&quot;status&quot;) ?: &quot;PRESENT&quot;&#10;                                )&#10;                            } ?: emptyList()&#10;                        &#10;                        // Update the adapter's data and notify changes&#10;                        val oldSize = attendanceList.size&#10;                        attendanceList.clear()&#10;                        attendanceList.addAll(newAttendanceList)&#10;                        attendanceAdapter?.notifyDataSetChanged()&#10;                        &#10;                        // Scroll to top if new items were added&#10;                        if (newAttendanceList.size &gt; oldSize) {&#10;                            attendanceRecyclerView.smoothScrollToPosition(0)&#10;                        }&#10;                        &#10;                        textAttendanceCount.text = &quot;Total: ${attendanceList.size}&quot;&#10;                        &#10;                        android.util.Log.d(TAG, &quot;✓✓✓ TEACHER LOADED ${attendanceList.size} ATTENDANCE RECORDS (LIVE UPDATE) ✓✓✓&quot;)&#10;                        android.util.Log.d(TAG, &quot;Subject: $subject, from ${formatTimestamp(classStartTimestamp)}&quot;)&#10;                        attendanceList.forEach { &#10;                            android.util.Log.d(TAG, &quot;  → ${it.studentName} at ${it.timeTaken}&quot;)&#10;                        }&#10;                    }&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                android.util.Log.e(TAG, &quot;Error getting schedule: ${e.message}&quot;, e)&#10;            }&#10;    }&#10;    &#10;    private fun parseTime24(time: String): Pair&lt;Int, Int&gt; {&#10;        return try {&#10;            val parts = time.split(&quot;:&quot;)&#10;            Pair(parts[0].toInt(), parts[1].toInt())&#10;        } catch (e: Exception) {&#10;            Pair(0, 0)&#10;        }&#10;    }&#10;&#10;    private fun loadRecentAttendanceFallback() {&#10;        // Load recent attendance with REAL-TIME updates - shows both active and archived&#10;        val uid = auth.currentUser?.uid ?: return&#10;        &#10;        // Remove any existing listener first&#10;        attendanceListener?.remove()&#10;        listeningScheduleId = null&#10;        listeningSubject = null&#10;        &#10;        android.util.Log.d(TAG, &quot;Loading fallback with REAL-TIME listener for active/archived attendance&quot;)&#10;        &#10;        // Get today's start for filtering archived records&#10;        val calendar = java.util.Calendar.getInstance()&#10;        calendar.set(java.util.Calendar.HOUR_OF_DAY, 0)&#10;        calendar.set(java.util.Calendar.MINUTE, 0)&#10;        calendar.set(java.util.Calendar.SECOND, 0)&#10;        calendar.set(java.util.Calendar.MILLISECOND, 0)&#10;        val todayMillis = calendar.timeInMillis&#10;        &#10;        // Set up REAL-TIME listener on active attendance (NO LIMIT to avoid index requirement)&#10;        attendanceListener = db.collection(&quot;attendance&quot;)&#10;            .whereEqualTo(&quot;teacherId&quot;, uid)&#10;            .addSnapshotListener { activeSnapshot, e -&gt;&#10;                if (e != null) {&#10;                    android.util.Log.e(TAG, &quot;Attendance fallback listen failed: ${e.message}&quot;, e)&#10;                    Toast.makeText(requireContext(), &quot;Error: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                    return@addSnapshotListener&#10;                }&#10;                &#10;                // Also check archived attendance (NO date filter to avoid composite index requirement)&#10;                db.collection(&quot;archived_attendance&quot;)&#10;                    .whereEqualTo(&quot;teacherId&quot;, uid)&#10;                    .get()&#10;                    .addOnSuccessListener { archivedSnapshot -&gt;&#10;                        // Filter archived records to only today (in memory)&#10;                        val archivedFromToday = archivedSnapshot.documents.filter {&#10;                            val archivedAt = it.getLong(&quot;archivedAt&quot;) ?: 0L&#10;                            archivedAt &gt;= todayMillis&#10;                        }&#10;                        &#10;                        // Combine both active and archived&#10;                        val allDocs = (activeSnapshot?.documents ?: emptyList()) + archivedFromToday&#10;                        &#10;                        // Sort by timestamp and limit in memory&#10;                        val sortedDocs = allDocs&#10;                            .sortedByDescending { it.getTimestamp(&quot;timestamp&quot;)?.seconds ?: 0 }&#10;                            .take(RECENT_ATTENDANCE_LIMIT)&#10;                        &#10;                        val newAttendanceList = sortedDocs.map { doc -&gt;&#10;                            TeacherAttendanceItem(&#10;                                documentId = doc.id,&#10;                                studentName = doc.getString(&quot;studentName&quot;) ?: &quot;Unknown Student&quot;,&#10;                                timeTaken = formatTimestamp(doc.getTimestamp(&quot;timestamp&quot;)),&#10;                                section = doc.getString(&quot;section&quot;) ?: &quot;&quot;,&#10;                                status = doc.getString(&quot;status&quot;) ?: &quot;PRESENT&quot;&#10;                            )&#10;                        }&#10;                        &#10;                        // Update the adapter's data and notify changes&#10;                        val oldSize = attendanceList.size&#10;                        attendanceList.clear()&#10;                        attendanceList.addAll(newAttendanceList)&#10;                        &#10;                        // Update the adapter's click handler to check archived status&#10;                        attendanceAdapter = TeacherAttendanceAdapter(attendanceList) { item -&gt;&#10;                            // Check if it's archived&#10;                            if (archivedFromToday.any { it.id == item.documentId }) {&#10;                                Toast.makeText(requireContext(), &quot;Cannot modify archived attendance&quot;, Toast.LENGTH_SHORT).show()&#10;                            } else {&#10;                                confirmAndRemoveAttendance(item)&#10;                            }&#10;                        }&#10;                        attendanceRecyclerView.adapter = attendanceAdapter&#10;                        &#10;                        // Scroll to top if new items were added&#10;                        if (newAttendanceList.size &gt; oldSize) {&#10;                            attendanceRecyclerView.smoothScrollToPosition(0)&#10;                        }&#10;                        &#10;                        val activeCount = activeSnapshot?.documents?.size ?: 0&#10;                        val archivedCount = archivedFromToday.size&#10;                        val label = if (archivedCount &gt; 0) &quot; ($activeCount active, $archivedCount archived)&quot; else &quot;&quot;&#10;                        textAttendanceCount.text = &quot;Total: ${attendanceList.size}$label&quot;&#10;                        &#10;                        android.util.Log.d(TAG, &quot;Loaded ${attendanceList.size} attendance records ($activeCount active, $archivedCount archived) with REAL-TIME updates&quot;)&#10;                    }&#10;                    .addOnFailureListener { archiveError -&gt;&#10;                        android.util.Log.e(TAG, &quot;Error loading archived attendance: ${archiveError.message}&quot;, archiveError)&#10;                        // Just show active attendance if archived query fails&#10;                        val sortedDocs = (activeSnapshot?.documents ?: emptyList())&#10;                            .sortedByDescending { it.getTimestamp(&quot;timestamp&quot;)?.seconds ?: 0 }&#10;                            .take(RECENT_ATTENDANCE_LIMIT)&#10;                        &#10;                        val newAttendanceList = sortedDocs.map { doc -&gt;&#10;                            TeacherAttendanceItem(&#10;                                documentId = doc.id,&#10;                                studentName = doc.getString(&quot;studentName&quot;) ?: &quot;Unknown Student&quot;,&#10;                                timeTaken = formatTimestamp(doc.getTimestamp(&quot;timestamp&quot;)),&#10;                                section = doc.getString(&quot;section&quot;) ?: &quot;&quot;,&#10;                                status = doc.getString(&quot;status&quot;) ?: &quot;PRESENT&quot;&#10;                            )&#10;                        }&#10;                        &#10;                        // Update the adapter's data&#10;                        attendanceList.clear()&#10;                        attendanceList.addAll(newAttendanceList)&#10;                        &#10;                        // Recreate adapter for consistency&#10;                        attendanceAdapter = TeacherAttendanceAdapter(attendanceList) { item -&gt;&#10;                            confirmAndRemoveAttendance(item)&#10;                        }&#10;                        attendanceRecyclerView.adapter = attendanceAdapter&#10;                        textAttendanceCount.text = &quot;Total: ${attendanceList.size}&quot;&#10;                    }&#10;            }&#10;    }&#10;&#10;    private fun confirmAndRemoveAttendance(item: TeacherAttendanceItem) {&#10;        AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Remove attendance&quot;)&#10;            .setMessage(&quot;Remove ${item.studentName}'s attendance?&quot;)&#10;            .setPositiveButton(&quot;Remove&quot;) { _, _ -&gt;&#10;                val db = FirebaseFirestore.getInstance()&#10;                val attendanceId = item.documentId&#10;                &#10;                // First, get the attendance document to archive it&#10;                db.collection(&quot;attendance&quot;)&#10;                    .document(attendanceId)&#10;                    .get()&#10;                    .addOnSuccessListener { document -&gt;&#10;                        if (document.exists()) {&#10;                            // Archive the document for historical analytics&#10;                            val archiveData = document.data?.toMutableMap() ?: mutableMapOf()&#10;                            archiveData[&quot;archivedAt&quot;] = System.currentTimeMillis()&#10;                            archiveData[&quot;originalId&quot;] = attendanceId&#10;                            &#10;                            db.collection(&quot;archived_attendance&quot;)&#10;                                .document(attendanceId)&#10;                                .set(archiveData)&#10;                                .addOnSuccessListener {&#10;                                    // Now delete from the active collection&#10;                                    db.collection(&quot;attendance&quot;)&#10;                                        .document(attendanceId)&#10;                                        .delete()&#10;                                        .addOnSuccessListener {&#10;                                            Toast.makeText(requireContext(), &quot;Removed ${item.studentName}&quot;, Toast.LENGTH_SHORT).show()&#10;                                        }&#10;                                        .addOnFailureListener { ex -&gt;&#10;                                            Toast.makeText(requireContext(), &quot;Failed: ${ex.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                                        }&#10;                                }&#10;                                .addOnFailureListener { ex -&gt;&#10;                                    // Even if archiving fails, still try to delete&#10;                                    db.collection(&quot;attendance&quot;)&#10;                                        .document(attendanceId)&#10;                                        .delete()&#10;                                        .addOnSuccessListener {&#10;                                            Toast.makeText(requireContext(), &quot;Removed ${item.studentName}&quot;, Toast.LENGTH_SHORT).show()&#10;                                        }&#10;                                }&#10;                        }&#10;                    }&#10;                    .addOnFailureListener { ex -&gt;&#10;                        Toast.makeText(requireContext(), &quot;Failed: ${ex.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;, null)&#10;            .show()&#10;    }&#10;    &#10;    private fun getCurrentDayOfWeek(): String {&#10;        val calendar = java.util.Calendar.getInstance()&#10;        val dayFormat = java.text.SimpleDateFormat(&quot;EEEE&quot;, java.util.Locale.getDefault())&#10;        return dayFormat.format(calendar.time)&#10;    }&#10;    &#10;    private fun parseTimeToHour(timeString: String): Int {&#10;        return try {&#10;            val parts = timeString.split(&quot;:&quot;)&#10;            parts[0].toInt()&#10;        } catch (e: Exception) {&#10;            0&#10;        }&#10;    }&#10;    &#10;    private fun formatTimestamp(timestamp: com.google.firebase.Timestamp?): String {&#10;        return timestamp?.toDate()?.let { date -&gt;&#10;            val format = java.text.SimpleDateFormat(&quot;HH:mm&quot;, java.util.Locale.getDefault())&#10;            format.format(date)&#10;        } ?: &quot;&quot;&#10;    }&#10;    &#10;    private fun showManualAddDialog() {&#10;        val currentUser = auth.currentUser ?: return&#10;        val nowMinutes = getCurrentTimeInMinutes()&#10;        val currentDay = getCurrentDayOfWeek()&#10;        &#10;        db.collection(&quot;schedules&quot;)&#10;            .whereEqualTo(&quot;teacherId&quot;, currentUser.uid)&#10;            .whereEqualTo(&quot;day&quot;, currentDay)&#10;            .get()&#10;            .addOnSuccessListener { scheduleDocs -&gt;&#10;                val todays = scheduleDocs.documents&#10;                val currentSchedule = todays.firstOrNull { doc -&gt;&#10;                    val start = doc.getString(&quot;startTime&quot;) ?: &quot;&quot;&#10;                    val end = doc.getString(&quot;endTime&quot;) ?: &quot;&quot;&#10;                    isNowWithinRange(nowMinutes, start, end)&#10;                }&#10;&#10;                fun proceedWith(doc: com.google.firebase.firestore.DocumentSnapshot) {&#10;                    val subject = doc.getString(&quot;subject&quot;) ?: &quot;&quot;&#10;                    val section = doc.getString(&quot;section&quot;) ?: &quot;&quot;&#10;                    loadStudentsForSection(section, subject, doc.id)&#10;                }&#10;&#10;                if (currentSchedule != null) {&#10;                    proceedWith(currentSchedule)&#10;                } else if (todays.isNotEmpty()) {&#10;                    showSchedulePicker(todays, title = &quot;Select class for manual add&quot;) { chosen -&gt;&#10;                        proceedWith(chosen)&#10;                    }&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;No schedules found for today&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Toast.makeText(requireContext(), &quot;Error loading schedule: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;    }&#10;&#10;    private fun getCurrentTimeInMinutes(): Int {&#10;        val cal = java.util.Calendar.getInstance()&#10;        return cal.get(java.util.Calendar.HOUR_OF_DAY) * 60 + cal.get(java.util.Calendar.MINUTE)&#10;    }&#10;&#10;    private fun parseTimeToMinutes24(time: String): Int? {&#10;        return try {&#10;            val parts = time.split(&quot;:&quot;)&#10;            val hour = parts.getOrNull(0)?.toInt() ?: return null&#10;            val minute = parts.getOrNull(1)?.toInt() ?: 0&#10;            hour * 60 + minute&#10;        } catch (_: Exception) { null }&#10;    }&#10;&#10;    private fun isNowWithinRange(nowMinutes: Int, start: String, end: String): Boolean {&#10;        val s = parseTimeToMinutes24(start) ?: return false&#10;        val e = parseTimeToMinutes24(end) ?: return false&#10;        return if (e &lt; s) {&#10;            nowMinutes &gt;= s || nowMinutes &lt;= e&#10;        } else {&#10;            nowMinutes in s until e&#10;        }&#10;    }&#10;&#10;    private fun showSchedulePicker(&#10;        schedules: List&lt;com.google.firebase.firestore.DocumentSnapshot&gt;,&#10;        title: String,&#10;        onChosen: (com.google.firebase.firestore.DocumentSnapshot) -&gt; Unit&#10;    ) {&#10;        val items = schedules.map { doc -&gt;&#10;            val subject = doc.getString(&quot;subject&quot;) ?: &quot;&quot;&#10;            val section = doc.getString(&quot;section&quot;) ?: &quot;&quot;&#10;            val start = doc.getString(&quot;startTime&quot;) ?: &quot;&quot;&#10;            val end = doc.getString(&quot;endTime&quot;) ?: &quot;&quot;&#10;            &quot;$subject ($section)  $start-$end&quot;&#10;        }.toTypedArray()&#10;&#10;        android.app.AlertDialog.Builder(requireContext())&#10;            .setTitle(title)&#10;            .setItems(items) { dialog, which -&gt;&#10;                onChosen(schedules[which])&#10;                dialog.dismiss()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;, null)&#10;            .show()&#10;    }&#10;    &#10;    private fun loadStudentsForSection(section: String, subject: String, scheduleId: String) {&#10;        val target = section.trim().lowercase()&#10;        db.collection(&quot;users&quot;)&#10;            .whereEqualTo(&quot;role&quot;, &quot;student&quot;)&#10;            .get()&#10;            .addOnSuccessListener { studentDocs -&gt;&#10;                val students = studentDocs&#10;                    .filter { (it.getString(&quot;role&quot;) ?: &quot;&quot;) == &quot;student&quot; }&#10;                    .mapNotNull { doc -&gt;&#10;                        val studentSection = (doc.getString(&quot;section&quot;) ?: &quot;&quot;).trim().lowercase()&#10;                        if (studentSection == target) {&#10;                            StudentItem(&#10;                                id = doc.id,&#10;                                name = doc.getString(&quot;name&quot;) ?: &quot;Unknown Student&quot;,&#10;                                email = doc.getString(&quot;email&quot;) ?: &quot;&quot;,&#10;                                section = doc.getString(&quot;section&quot;) ?: &quot;&quot;&#10;                            )&#10;                        } else null&#10;                    }&#10;                &#10;                if (students.isNotEmpty()) {&#10;                    showStudentSelectionDialog(students, subject, scheduleId)&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;No students found in section $section&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Toast.makeText(requireContext(), &quot;Error loading students: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;    }&#10;    &#10;    private fun showStudentSelectionDialog(students: List&lt;StudentItem&gt;, subject: String, scheduleId: String) {&#10;        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_manual_add_student, null)&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setView(dialogView)&#10;            .create()&#10;        &#10;        val textCurrentSession = dialogView.findViewById&lt;TextView&gt;(R.id.textCurrentSession)&#10;        val radioPresent = dialogView.findViewById&lt;RadioButton&gt;(R.id.radioPresent)&#10;        val radioExcused = dialogView.findViewById&lt;RadioButton&gt;(R.id.radioExcused)&#10;        val radioAbsent = dialogView.findViewById&lt;RadioButton&gt;(R.id.radioAbsent)&#10;&#10;        // RadioGroup is defined in XML now; nothing needed here&#10;        val btnCancel = dialogView.findViewById&lt;Button&gt;(R.id.btnCancel)&#10;        val btnAddStudent = dialogView.findViewById&lt;Button&gt;(R.id.btnAddStudent)&#10;        &#10;        textCurrentSession.text = &quot;Current Session: $subject&quot;&#10;        &#10;        // Setup autocomplete for student names&#10;        val autoComplete = dialogView.findViewById&lt;AutoCompleteTextView&gt;(R.id.editStudentName)&#10;        val studentNames = students.map { it.name }&#10;        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_dropdown_item_1line, studentNames)&#10;        autoComplete.setAdapter(adapter)&#10;        &#10;        btnCancel.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;        &#10;        btnAddStudent.setOnClickListener {&#10;            val studentName = dialogView.findViewById&lt;AutoCompleteTextView&gt;(R.id.editStudentName).text.toString().trim()&#10;            &#10;            if (studentName.isEmpty()) {&#10;                Toast.makeText(requireContext(), &quot;Please enter a student name&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;            &#10;            // Get selected status&#10;            val status = when {&#10;                radioExcused.isChecked -&gt; &quot;EXCUSED&quot;&#10;                radioAbsent.isChecked -&gt; &quot;ABSENT&quot;&#10;                else -&gt; &quot;PRESENT&quot;&#10;            }&#10;            &#10;            // Find the student in our list&#10;            val selectedStudent = students.find { it.name.equals(studentName, ignoreCase = true) }&#10;            if (selectedStudent != null) {&#10;                addStudentsManually(listOf(selectedStudent), subject, scheduleId, status)&#10;                dialog.dismiss()&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;Student '$studentName' not found in current section&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;        &#10;        dialog.show()&#10;    }&#10;    &#10;    private fun addStudentsManually(students: List&lt;StudentItem&gt;, subject: String, scheduleId: String, status: String) {&#10;        val currentUser = auth.currentUser ?: return&#10;        val currentTime = com.google.firebase.Timestamp.now()&#10;        &#10;        android.util.Log.d(TAG, &quot;Manually adding ${students.size} students to attendance - Subject: $subject, Status: $status&quot;)&#10;        &#10;        students.forEach { student -&gt;&#10;            val attendanceData = hashMapOf(&#10;                &quot;userId&quot; to student.id,&#10;                &quot;studentName&quot; to student.name,&#10;                &quot;sessionId&quot; to &quot;MANUAL_${System.currentTimeMillis()}&quot;, // Unique session ID for manual entries&#10;                &quot;teacherId&quot; to currentUser.uid,&#10;                &quot;scheduleId&quot; to scheduleId,&#10;                &quot;subject&quot; to subject,&#10;                &quot;section&quot; to student.section,&#10;                &quot;timestamp&quot; to currentTime,&#10;                &quot;status&quot; to status,&#10;                &quot;location&quot; to &quot;&quot;,&#10;                &quot;notes&quot; to &quot;Manually added by teacher - Status: $status&quot;,&#10;                &quot;isManualEntry&quot; to true // Flag to identify manual entries&#10;            )&#10;            &#10;            android.util.Log.d(TAG, &quot;Adding manual attendance: ${student.name} - $subject (${student.section}) - $status&quot;)&#10;            &#10;            db.collection(&quot;attendance&quot;).add(attendanceData)&#10;                .addOnSuccessListener { docRef -&gt;&#10;                    android.util.Log.d(TAG, &quot;Successfully added manual attendance for ${student.name} with ID: ${docRef.id}&quot;)&#10;                    Toast.makeText(requireContext(), &quot;Added ${student.name} to attendance&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;                .addOnFailureListener { e -&gt;&#10;                    android.util.Log.e(TAG, &quot;Failed to add manual attendance for ${student.name}: ${e.message}&quot;, e)&#10;                    Toast.makeText(requireContext(), &quot;Failed to add ${student.name}: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;        }&#10;        // Ensure we are listening to updates for this schedule so the UI reflects changes instantly&#10;        startAttendanceListener(scheduleId, subject)&#10;    }&#10;&#10;    private fun confirmEndClass() {&#10;        AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;End Class&quot;)&#10;            .setMessage(&quot;This will archive all attendance from this class session. The attendance will be removed from Recent Attendance but kept for analytics. Continue?&quot;)&#10;            .setPositiveButton(&quot;End Class&quot;) { _, _ -&gt;&#10;                archiveCurrentClassAttendance()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;, null)&#10;            .show()&#10;    }&#10;    &#10;    private fun archiveCurrentClassAttendance() {&#10;        val scheduleId = listeningScheduleId ?: return&#10;        val subject = listeningSubject ?: return&#10;        val currentUser = auth.currentUser ?: return&#10;        &#10;        viewLifecycleOwner.lifecycleScope.launch {&#10;            try {&#10;                // Get all attendance records for the current class session&#10;                val attendanceSnapshot = db.collection(&quot;attendance&quot;)&#10;                    .whereEqualTo(&quot;teacherId&quot;, currentUser.uid)&#10;                    .whereEqualTo(&quot;scheduleId&quot;, scheduleId)&#10;                    .whereEqualTo(&quot;subject&quot;, subject)&#10;                    .get()&#10;                    .await()&#10;                &#10;                android.util.Log.d(TAG, &quot;Archiving ${attendanceSnapshot.size()} attendance records for $subject&quot;)&#10;                &#10;                var archivedCount = 0&#10;                // Archive each record&#10;                for (doc in attendanceSnapshot.documents) {&#10;                    val archiveData = doc.data?.toMutableMap() ?: continue&#10;                    archiveData[&quot;archivedAt&quot;] = System.currentTimeMillis()&#10;                    archiveData[&quot;originalId&quot;] = doc.id&#10;                    &#10;                    // Add to archived collection&#10;                    db.collection(&quot;archived_attendance&quot;)&#10;                        .document(doc.id)&#10;                        .set(archiveData)&#10;                        .await()&#10;                    &#10;                    // Delete from active collection&#10;                    doc.reference.delete().await()&#10;                    archivedCount++&#10;                }&#10;                &#10;                // Hide the End Class button&#10;                buttonEndClass.visibility = View.GONE&#10;                &#10;                // Clear the current listening state&#10;                attendanceListener?.remove()&#10;                listeningScheduleId = null&#10;                listeningSubject = null&#10;                &#10;                // Reload to show empty/next class&#10;                loadRecentAttendance()&#10;                &#10;                Toast.makeText(requireContext(), &quot;Class ended. $archivedCount records archived.&quot;, Toast.LENGTH_SHORT).show()&#10;                android.util.Log.d(TAG, &quot;Successfully archived $archivedCount attendance records&quot;)&#10;                &#10;            } catch (e: Exception) {&#10;                android.util.Log.e(TAG, &quot;Error archiving attendance: ${e.message}&quot;, e)&#10;                Toast.makeText(requireContext(), &quot;Error archiving attendance: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun archiveEndedClassesAttendance(endedSchedules: List&lt;com.google.firebase.firestore.DocumentSnapshot&gt;) {&#10;        val currentUser = auth.currentUser ?: return&#10;        &#10;        viewLifecycleOwner.lifecycleScope.launch {&#10;            try {&#10;                var totalArchived = 0&#10;                &#10;                for (schedule in endedSchedules) {&#10;                    val scheduleId = schedule.id&#10;                    val subject = schedule.getString(&quot;subject&quot;) ?: continue&#10;                    &#10;                    // Get attendance records for this ended class from today&#10;                    val calendar = java.util.Calendar.getInstance()&#10;                    calendar.set(java.util.Calendar.HOUR_OF_DAY, 0)&#10;                    calendar.set(java.util.Calendar.MINUTE, 0)&#10;                    calendar.set(java.util.Calendar.SECOND, 0)&#10;                    calendar.set(java.util.Calendar.MILLISECOND, 0)&#10;                    val todayStart = com.google.firebase.Timestamp(calendar.time)&#10;                    &#10;                    val attendanceSnapshot = db.collection(&quot;attendance&quot;)&#10;                        .whereEqualTo(&quot;teacherId&quot;, currentUser.uid)&#10;                        .whereEqualTo(&quot;scheduleId&quot;, scheduleId)&#10;                        .whereEqualTo(&quot;subject&quot;, subject)&#10;                        .whereGreaterThanOrEqualTo(&quot;timestamp&quot;, todayStart)&#10;                        .get()&#10;                        .await()&#10;                    &#10;                    // Archive each record&#10;                    for (doc in attendanceSnapshot.documents) {&#10;                        val archiveData = doc.data?.toMutableMap() ?: continue&#10;                        archiveData[&quot;archivedAt&quot;] = System.currentTimeMillis()&#10;                        archiveData[&quot;originalId&quot;] = doc.id&#10;                        archiveData[&quot;autoArchived&quot;] = true&#10;                        &#10;                        // Add to archived collection&#10;                        db.collection(&quot;archived_attendance&quot;)&#10;                            .document(doc.id)&#10;                            .set(archiveData)&#10;                            .await()&#10;                        &#10;                        // Delete from active collection&#10;                        doc.reference.delete().await()&#10;                        totalArchived++&#10;                    }&#10;                    &#10;                    android.util.Log.d(TAG, &quot;Auto-archived ${attendanceSnapshot.size()} records from ended class: $subject&quot;)&#10;                }&#10;                &#10;                if (totalArchived &gt; 0) {&#10;                    android.util.Log.d(TAG, &quot;Auto-archived total of $totalArchived attendance records from ${endedSchedules.size} ended classes&quot;)&#10;                }&#10;                &#10;            } catch (e: Exception) {&#10;                android.util.Log.e(TAG, &quot;Error auto-archiving ended classes: ${e.message}&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun scheduleAutoArchiveAtClassEnd(endTime: String) {&#10;        // Cancel any existing scheduled archiving&#10;        classEndRunnable?.let { classEndHandler.removeCallbacks(it) }&#10;        &#10;        try {&#10;            // Calculate milliseconds until class ends&#10;            val (endHour, endMin) = parseTime24(endTime)&#10;            val now = java.util.Calendar.getInstance()&#10;            val classEnd = java.util.Calendar.getInstance().apply {&#10;                set(java.util.Calendar.HOUR_OF_DAY, endHour)&#10;                set(java.util.Calendar.MINUTE, endMin)&#10;                set(java.util.Calendar.SECOND, 0)&#10;                set(java.util.Calendar.MILLISECOND, 0)&#10;            }&#10;            &#10;            val millisUntilEnd = classEnd.timeInMillis - now.timeInMillis&#10;            &#10;            if (millisUntilEnd &gt; 0) {&#10;                classEndRunnable = Runnable {&#10;                    android.util.Log.d(TAG, &quot;Class end time reached - auto-archiving attendance&quot;)&#10;                    archiveCurrentClassAttendance()&#10;                }&#10;                classEndHandler.postDelayed(classEndRunnable!!, millisUntilEnd)&#10;                android.util.Log.d(TAG, &quot;Scheduled auto-archive in ${millisUntilEnd / 1000 / 60} minutes at $endTime&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(TAG, &quot;Error scheduling auto-archive: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        attendanceListener?.remove()&#10;        attendanceListener = null&#10;        listeningScheduleId = null&#10;        listeningSubject = null&#10;        attendanceAdapter = null&#10;        attendanceList.clear()&#10;        classEndRunnable?.let { classEndHandler.removeCallbacks(it) }&#10;    }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.attendancesystem&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.fragment.app.Fragment&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.attendancesystem.utils.ProfilePictureManager&#10;import com.example.attendancesystem.models.TeacherAttendanceItem&#10;import com.example.attendancesystem.models.StudentItem&#10;import com.example.attendancesystem.adapters.TeacherAttendanceAdapter&#10;import com.example.attendancesystem.adapters.StudentSelectionAdapter&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import android.app.AlertDialog&#10;import android.widget.ArrayAdapter&#10;import android.widget.AutoCompleteTextView&#10;import android.widget.RadioButton&#10;import com.google.firebase.firestore.ListenerRegistration&#10;import androidx.lifecycle.lifecycleScope&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;class TeacherDashboardFragment : Fragment() {&#10;    companion object {&#10;        private const val RECENT_ATTENDANCE_LIMIT = 100&#10;        private const val TAG = &quot;TeacherDashboard&quot;&#10;    }&#10;    private lateinit var imageProfilePic: ImageView&#10;    private lateinit var textInitials: TextView&#10;    private lateinit var textName: TextView&#10;    private lateinit var textDepartment: TextView&#10;    private lateinit var textQrExpiry: TextView&#10;    private lateinit var buttonShowQr: Button&#10;    private lateinit var buttonRenewQr: Button&#10;    private lateinit var buttonRefreshAttendance: Button&#10;    private lateinit var buttonManualAdd: Button&#10;    private lateinit var buttonAnalytics: Button&#10;    private lateinit var buttonEndClass: Button&#10;    private lateinit var attendanceRecyclerView: RecyclerView&#10;    private lateinit var textAttendanceCount: TextView&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;    private var attendanceListener: ListenerRegistration? = null&#10;    private var listeningScheduleId: String? = null&#10;    private var listeningSubject: String? = null&#10;    private var currentScheduleEndTime: String? = null&#10;    private val classEndHandler = android.os.Handler(android.os.Looper.getMainLooper())&#10;    private var classEndRunnable: Runnable? = null&#10;    private var attendanceAdapter: TeacherAttendanceAdapter? = null&#10;    private val attendanceList = mutableListOf&lt;TeacherAttendanceItem&gt;()&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        return inflater.inflate(R.layout.fragment_teacher_dashboard, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        initializeViews(view)&#10;        setupClickListeners()&#10;        loadUserData()&#10;        loadRecentAttendance()&#10;    }&#10;    &#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Re-attach listener when fragment becomes visible again&#10;        if (attendanceListener == null &amp;&amp; (listeningScheduleId != null || listeningSubject != null)) {&#10;            listeningScheduleId?.let { scheduleId -&gt;&#10;                listeningSubject?.let { subject -&gt;&#10;                    startAttendanceListener(scheduleId, subject)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeViews(view: View) {&#10;        imageProfilePic = view.findViewById(R.id.imageProfilePic)&#10;        textInitials = view.findViewById(R.id.textInitials)&#10;        textName = view.findViewById(R.id.textName)&#10;        textDepartment = view.findViewById(R.id.textDepartment)&#10;        textQrExpiry = view.findViewById(R.id.textQrExpiry)&#10;        buttonShowQr = view.findViewById(R.id.buttonShowQr)&#10;        buttonRenewQr = view.findViewById(R.id.buttonRenewQr)&#10;        buttonRefreshAttendance = view.findViewById(R.id.buttonRefreshAttendance)&#10;        buttonManualAdd = view.findViewById(R.id.buttonManualAdd)&#10;        buttonAnalytics = view.findViewById(R.id.buttonAnalytics)&#10;        buttonEndClass = view.findViewById(R.id.buttonEndClass)&#10;        attendanceRecyclerView = view.findViewById(R.id.attendanceRecyclerView)&#10;        textAttendanceCount = view.findViewById(R.id.textAttendanceCount)&#10;        &#10;        // Setup RecyclerView with adapter&#10;        attendanceRecyclerView.layoutManager = LinearLayoutManager(requireContext())&#10;        attendanceAdapter = TeacherAttendanceAdapter(attendanceList) { item -&gt;&#10;            confirmAndRemoveAttendance(item)&#10;        }&#10;        attendanceRecyclerView.adapter = attendanceAdapter&#10;    }&#10;    &#10;    private fun setupClickListeners() {&#10;        buttonShowQr.setOnClickListener {&#10;            // Show QR: Open QR activity to show existing QR (or create if none exists)&#10;            showQRCode(forceNew = false)&#10;        }&#10;        &#10;        buttonRenewQr.setOnClickListener {&#10;            // Renew QR: Force delete old sessions and create fresh QR code&#10;            showQRCode(forceNew = true)&#10;        }&#10;        &#10;        buttonRefreshAttendance.setOnClickListener {&#10;            // Force remove existing listener and reload fresh&#10;            attendanceListener?.remove()&#10;            attendanceListener = null&#10;            listeningScheduleId = null&#10;            listeningSubject = null&#10;            loadRecentAttendance()&#10;        }&#10;        &#10;        buttonManualAdd.setOnClickListener {&#10;            showManualAddDialog()&#10;        }&#10;        &#10;        buttonAnalytics.setOnClickListener {&#10;            val intent = Intent(requireContext(), TeacherMainActivity::class.java)&#10;            intent.putExtra(&quot;open&quot;, &quot;analytics&quot;)&#10;            startActivity(intent)&#10;        }&#10;        &#10;        buttonEndClass.setOnClickListener {&#10;            confirmEndClass()&#10;        }&#10;    }&#10;    &#10;    private fun loadUserData() {&#10;        val currentUser = auth.currentUser&#10;        currentUser?.let {&#10;            db.collection(&quot;users&quot;).document(it.uid)&#10;                .addSnapshotListener { snapshot, _ -&gt;&#10;                    if (snapshot != null &amp;&amp; snapshot.exists()) {&#10;                        val name = snapshot.getString(&quot;name&quot;) ?: &quot;Teacher&quot;&#10;                        val department = snapshot.getString(&quot;department&quot;) ?: &quot;Department&quot;&#10;                        textName.text = name&#10;                        textDepartment.text = department&#10;                        ProfilePictureManager.getInstance().loadProfilePicture(requireContext(), imageProfilePic, textInitials, name, &quot;TC&quot;)&#10;                    }&#10;                }&#10;        }&#10;    }&#10;    &#10;    private fun showQRCode(forceNew: Boolean = false) {&#10;        val currentUser = auth.currentUser ?: run {&#10;            Toast.makeText(requireContext(), &quot;Not signed in&quot;, Toast.LENGTH_SHORT).show(); return&#10;        }&#10;&#10;        val currentDay = getCurrentDayOfWeek()&#10;        val nowMinutes = getCurrentTimeInMinutes()&#10;&#10;        db.collection(&quot;schedules&quot;)&#10;            .whereEqualTo(&quot;teacherId&quot;, currentUser.uid)&#10;            .whereEqualTo(&quot;day&quot;, currentDay)&#10;            .get()&#10;            .addOnSuccessListener { scheduleDocs -&gt;&#10;                val todays = scheduleDocs.documents&#10;                val match = todays.firstOrNull { doc -&gt;&#10;                    val start = doc.getString(&quot;startTime&quot;) ?: &quot;&quot;&#10;                    val end = doc.getString(&quot;endTime&quot;) ?: &quot;&quot;&#10;                    isNowWithinRange(nowMinutes, start, end)&#10;                }&#10;&#10;                fun launchFor(doc: com.google.firebase.firestore.DocumentSnapshot) {&#10;                    val intent = android.content.Intent(requireContext(), QRActivity::class.java).apply {&#10;                        putExtra(&quot;scheduleId&quot;, doc.id)&#10;                        putExtra(&quot;subject&quot;, doc.getString(&quot;subject&quot;) ?: &quot;Attendance&quot;)&#10;                        putExtra(&quot;section&quot;, doc.getString(&quot;section&quot;) ?: &quot;&quot;)&#10;                        putExtra(&quot;forceNew&quot;, forceNew) // Pass flag to force new QR&#10;                    }&#10;                    startActivity(intent)&#10;                }&#10;&#10;                if (match != null) {&#10;                    launchFor(match)&#10;                } else {&#10;                    // No current class — find next upcoming today and inform the teacher&#10;                    val next = todays&#10;                        .mapNotNull { doc -&gt;&#10;                            val start = doc.getString(&quot;startTime&quot;) ?: return@mapNotNull null&#10;                            val startMin = parseTimeToMinutes24(start) ?: return@mapNotNull null&#10;                            Pair(startMin, doc)&#10;                        }&#10;                        .filter { it.first &gt; nowMinutes }&#10;                        .minByOrNull { it.first }&#10;                        ?.second&#10;&#10;                    if (next != null) {&#10;                        val subj = next.getString(&quot;subject&quot;) ?: &quot;&quot;&#10;                        val sec = next.getString(&quot;section&quot;) ?: &quot;&quot;&#10;                        val start = next.getString(&quot;startTime&quot;) ?: &quot;&quot;&#10;                        Toast.makeText(requireContext(), &quot;No current class. Next: $subj ($sec) at $start&quot;, Toast.LENGTH_LONG).show()&#10;                    } else if (todays.isNotEmpty()) {&#10;                        Toast.makeText(requireContext(), &quot;No more classes today&quot;, Toast.LENGTH_LONG).show()&#10;                    } else {&#10;                        Toast.makeText(requireContext(), &quot;No schedules found for today&quot;, Toast.LENGTH_LONG).show()&#10;                    }&#10;                }&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Toast.makeText(requireContext(), &quot;Error loading schedule: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;    }&#10;    &#10;    private fun renewQRCode() {&#10;        // Simply re-open QRActivity to generate a fresh QR for the current class&#10;        showQRCode()&#10;    }&#10;    &#10;    private fun loadRecentAttendance() {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser != null) {&#10;            val currentDay = getCurrentDayOfWeek()&#10;            val nowMinutes = getCurrentTimeInMinutes()&#10;            // Find today's schedules and determine the current class with minute precision&#10;            db.collection(&quot;schedules&quot;)&#10;                .whereEqualTo(&quot;teacherId&quot;, currentUser.uid)&#10;                .whereEqualTo(&quot;day&quot;, currentDay)&#10;                .get()&#10;                .addOnSuccessListener { scheduleDocs -&gt;&#10;                    if (scheduleDocs.isEmpty()) {&#10;                        // No schedule for today — show recent attendance fallback&#10;                        textQrExpiry.text = &quot;No classes scheduled for today&quot;&#10;                        loadRecentAttendanceFallback()&#10;                        return@addOnSuccessListener&#10;                    }&#10;                    &#10;                    // Find the current class based on precise minutes (supports crossing midnight)&#10;                    val currentSchedule = scheduleDocs.documents.firstOrNull { doc -&gt;&#10;                        val startTime = doc.getString(&quot;startTime&quot;) ?: &quot;&quot;&#10;                        val endTime = doc.getString(&quot;endTime&quot;) ?: &quot;&quot;&#10;                        isNowWithinRange(nowMinutes, startTime, endTime)&#10;                    }&#10;                    &#10;                    if (currentSchedule != null) {&#10;                        val scheduleId = currentSchedule.id&#10;                        val subject = currentSchedule.getString(&quot;subject&quot;) ?: &quot;&quot;&#10;                        val section = currentSchedule.getString(&quot;section&quot;) ?: &quot;&quot;&#10;                        &#10;                        // Update QR status&#10;                        textQrExpiry.text = &quot;Current Class: $subject ($section)&quot;&#10;                        // Start realtime listener for this class&#10;                        startAttendanceListener(scheduleId, subject)&#10;                    } else {&#10;                        // No current class — archive any old attendance from ended classes today&#10;                        val endedSchedules = scheduleDocs.documents&#10;                            .filter { doc -&gt;&#10;                                val endTime = doc.getString(&quot;endTime&quot;) ?: return@filter false&#10;                                val endMin = parseTimeToMinutes24(endTime) ?: return@filter false&#10;                                // Check if class has ended&#10;                                if (endMin &lt; parseTimeToMinutes24(doc.getString(&quot;startTime&quot;) ?: &quot;00:00&quot;) ?: 0) {&#10;                                    // Class crosses midnight - check if we're past the end time in the new day&#10;                                    nowMinutes &gt; endMin &amp;&amp; nowMinutes &lt; 720 // Before noon means new day&#10;                                } else {&#10;                                    nowMinutes &gt; endMin&#10;                                }&#10;                            }&#10;                        &#10;                        // Archive attendance from all ended classes today&#10;                        if (endedSchedules.isNotEmpty()) {&#10;                            archiveEndedClassesAttendance(endedSchedules)&#10;                        }&#10;                        &#10;                        // Show next class info&#10;                        val nextSchedule = scheduleDocs.documents&#10;                            .mapNotNull { doc -&gt;&#10;                                val startTime = doc.getString(&quot;startTime&quot;) ?: return@mapNotNull null&#10;                                val startMin = parseTimeToMinutes24(startTime) ?: return@mapNotNull null&#10;                                Pair(startMin, doc)&#10;                            }&#10;                            .filter { it.first &gt; nowMinutes }&#10;                            .minByOrNull { it.first }&#10;                            ?.second&#10;                        &#10;                        if (nextSchedule != null) {&#10;                            val subject = nextSchedule.getString(&quot;subject&quot;) ?: &quot;&quot;&#10;                            val section = nextSchedule.getString(&quot;section&quot;) ?: &quot;&quot;&#10;                            val startTime = nextSchedule.getString(&quot;startTime&quot;) ?: &quot;&quot;&#10;                            textQrExpiry.text = &quot;Next Class: $subject ($section) at $startTime&quot;&#10;                        } else {&#10;                            textQrExpiry.text = &quot;No classes scheduled for today&quot;&#10;                        }&#10;                        &#10;                        // Stop any existing listener since no current class&#10;                        attendanceListener?.remove()&#10;                        attendanceListener = null&#10;                        listeningScheduleId = null&#10;                        listeningSubject = null&#10;                        buttonEndClass.visibility = View.GONE&#10;                        loadRecentAttendanceFallback()&#10;                    }&#10;                }&#10;                .addOnFailureListener { e -&gt;&#10;                    Toast.makeText(requireContext(), &quot;Error loading schedule: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;        }&#10;    }&#10;&#10;    private fun startAttendanceListener(scheduleId: String, subject: String) {&#10;        val currentUser = auth.currentUser ?: return&#10;        if (listeningScheduleId == scheduleId &amp;&amp; listeningSubject == subject &amp;&amp; attendanceListener != null) {&#10;            return&#10;        }&#10;        attendanceListener?.remove()&#10;        listeningScheduleId = scheduleId&#10;        listeningSubject = subject&#10;        &#10;        // Get the class start and end time for filtering and auto-archiving&#10;        db.collection(&quot;schedules&quot;).document(scheduleId)&#10;            .get()&#10;            .addOnSuccessListener { scheduleDoc -&gt;&#10;                val startTime = scheduleDoc.getString(&quot;startTime&quot;) ?: &quot;00:00&quot;&#10;                val endTime = scheduleDoc.getString(&quot;endTime&quot;) ?: &quot;23:59&quot;&#10;                &#10;                // Store end time for scheduling&#10;                currentScheduleEndTime = endTime&#10;                &#10;                // Show the &quot;End Class&quot; button for current class&#10;                buttonEndClass.visibility = View.VISIBLE&#10;                &#10;                // Schedule auto-archive when class ends&#10;                scheduleAutoArchiveAtClassEnd(endTime)&#10;                &#10;                // Calculate today's class start timestamp&#10;                val calendar = java.util.Calendar.getInstance()&#10;                val (startHour, startMin) = parseTime24(startTime)&#10;                calendar.set(java.util.Calendar.HOUR_OF_DAY, startHour)&#10;                calendar.set(java.util.Calendar.MINUTE, startMin)&#10;                calendar.set(java.util.Calendar.SECOND, 0)&#10;                calendar.set(java.util.Calendar.MILLISECOND, 0)&#10;                val classStartTimestamp = com.google.firebase.Timestamp(calendar.time)&#10;                &#10;                // Listen for attendance from this class session only (after class start time)&#10;                // Exclude archived records by only querying the attendance collection (not archived_attendance)&#10;                android.util.Log.d(TAG, &quot;=== TEACHER QUERYING ATTENDANCE ===&quot;)&#10;                android.util.Log.d(TAG, &quot;teacherId: ${currentUser.uid}&quot;)&#10;                android.util.Log.d(TAG, &quot;scheduleId: $scheduleId&quot;)&#10;                android.util.Log.d(TAG, &quot;subject: $subject&quot;)&#10;                android.util.Log.d(TAG, &quot;timestamp &gt;= $classStartTimestamp&quot;)&#10;                attendanceListener = db.collection(&quot;attendance&quot;)&#10;                    .whereEqualTo(&quot;teacherId&quot;, currentUser.uid)&#10;                    .whereEqualTo(&quot;scheduleId&quot;, scheduleId)&#10;                    .whereEqualTo(&quot;subject&quot;, subject)&#10;                    .whereGreaterThanOrEqualTo(&quot;timestamp&quot;, classStartTimestamp)&#10;                    .addSnapshotListener { snapshot, e -&gt;&#10;                        if (e != null) {&#10;                            android.util.Log.e(TAG, &quot;Attendance listen failed: ${e.message}&quot;, e)&#10;                            Toast.makeText(requireContext(), &quot;Attendance listen failed: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                            return@addSnapshotListener&#10;                        }&#10;                        &#10;                        // Sort by timestamp in memory to avoid composite index requirement&#10;                        val newAttendanceList = snapshot?.documents&#10;                            ?.sortedByDescending { doc -&gt; &#10;                                doc.getTimestamp(&quot;timestamp&quot;)?.seconds ?: 0L &#10;                            }&#10;                            ?.map { doc -&gt;&#10;                                TeacherAttendanceItem(&#10;                                    documentId = doc.id,&#10;                                    studentName = doc.getString(&quot;studentName&quot;) ?: &quot;Unknown Student&quot;,&#10;                                    timeTaken = formatTimestamp(doc.getTimestamp(&quot;timestamp&quot;)),&#10;                                    section = doc.getString(&quot;section&quot;) ?: &quot;&quot;,&#10;                                    status = doc.getString(&quot;status&quot;) ?: &quot;PRESENT&quot;&#10;                                )&#10;                            } ?: emptyList()&#10;                        &#10;                        // Update the adapter's data and notify changes&#10;                        val oldSize = attendanceList.size&#10;                        attendanceList.clear()&#10;                        attendanceList.addAll(newAttendanceList)&#10;                        attendanceAdapter?.notifyDataSetChanged()&#10;                        &#10;                        // Scroll to top if new items were added&#10;                        if (newAttendanceList.size &gt; oldSize) {&#10;                            attendanceRecyclerView.smoothScrollToPosition(0)&#10;                        }&#10;                        &#10;                        textAttendanceCount.text = &quot;Total: ${attendanceList.size}&quot;&#10;                        &#10;                        android.util.Log.d(TAG, &quot;✓✓✓ TEACHER LOADED ${attendanceList.size} ATTENDANCE RECORDS (LIVE UPDATE) ✓✓✓&quot;)&#10;                        android.util.Log.d(TAG, &quot;Subject: $subject, from ${formatTimestamp(classStartTimestamp)}&quot;)&#10;                        attendanceList.forEach { &#10;                            android.util.Log.d(TAG, &quot;  → ${it.studentName} at ${it.timeTaken}&quot;)&#10;                        }&#10;                    }&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                android.util.Log.e(TAG, &quot;Error getting schedule: ${e.message}&quot;, e)&#10;            }&#10;    }&#10;    &#10;    private fun parseTime24(time: String): Pair&lt;Int, Int&gt; {&#10;        return try {&#10;            val parts = time.split(&quot;:&quot;)&#10;            Pair(parts[0].toInt(), parts[1].toInt())&#10;        } catch (e: Exception) {&#10;            Pair(0, 0)&#10;        }&#10;    }&#10;&#10;    private fun loadRecentAttendanceFallback() {&#10;        // Load recent attendance with REAL-TIME updates - shows both active and archived&#10;        val uid = auth.currentUser?.uid ?: return&#10;        &#10;        // Remove any existing listener first&#10;        attendanceListener?.remove()&#10;        listeningScheduleId = null&#10;        listeningSubject = null&#10;        &#10;        android.util.Log.d(TAG, &quot;Loading fallback with REAL-TIME listener for active/archived attendance&quot;)&#10;        &#10;        // Get today's start for filtering archived records&#10;        val calendar = java.util.Calendar.getInstance()&#10;        calendar.set(java.util.Calendar.HOUR_OF_DAY, 0)&#10;        calendar.set(java.util.Calendar.MINUTE, 0)&#10;        calendar.set(java.util.Calendar.SECOND, 0)&#10;        calendar.set(java.util.Calendar.MILLISECOND, 0)&#10;        val todayMillis = calendar.timeInMillis&#10;        &#10;        // Set up REAL-TIME listener on active attendance (NO LIMIT to avoid index requirement)&#10;        attendanceListener = db.collection(&quot;attendance&quot;)&#10;            .whereEqualTo(&quot;teacherId&quot;, uid)&#10;            .addSnapshotListener { activeSnapshot, e -&gt;&#10;                if (e != null) {&#10;                    android.util.Log.e(TAG, &quot;Attendance fallback listen failed: ${e.message}&quot;, e)&#10;                    Toast.makeText(requireContext(), &quot;Error: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                    return@addSnapshotListener&#10;                }&#10;                &#10;                // Also check archived attendance (NO date filter to avoid composite index requirement)&#10;                db.collection(&quot;archived_attendance&quot;)&#10;                    .whereEqualTo(&quot;teacherId&quot;, uid)&#10;                    .get()&#10;                    .addOnSuccessListener { archivedSnapshot -&gt;&#10;                        // Filter archived records to only today (in memory)&#10;                        val archivedFromToday = archivedSnapshot.documents.filter {&#10;                            val archivedAt = it.getLong(&quot;archivedAt&quot;) ?: 0L&#10;                            archivedAt &gt;= todayMillis&#10;                        }&#10;                        &#10;                        // Combine both active and archived&#10;                        val allDocs = (activeSnapshot?.documents ?: emptyList()) + archivedFromToday&#10;                        &#10;                        // Sort by timestamp and limit in memory&#10;                        val sortedDocs = allDocs&#10;                            .sortedByDescending { it.getTimestamp(&quot;timestamp&quot;)?.seconds ?: 0 }&#10;                            .take(RECENT_ATTENDANCE_LIMIT)&#10;                        &#10;                        val newAttendanceList = sortedDocs.map { doc -&gt;&#10;                            TeacherAttendanceItem(&#10;                                documentId = doc.id,&#10;                                studentName = doc.getString(&quot;studentName&quot;) ?: &quot;Unknown Student&quot;,&#10;                                timeTaken = formatTimestamp(doc.getTimestamp(&quot;timestamp&quot;)),&#10;                                section = doc.getString(&quot;section&quot;) ?: &quot;&quot;,&#10;                                status = doc.getString(&quot;status&quot;) ?: &quot;PRESENT&quot;&#10;                            )&#10;                        }&#10;                        &#10;                        // Update the adapter's data and notify changes&#10;                        val oldSize = attendanceList.size&#10;                        attendanceList.clear()&#10;                        attendanceList.addAll(newAttendanceList)&#10;                        &#10;                        // Update the adapter's click handler to check archived status&#10;                        attendanceAdapter = TeacherAttendanceAdapter(attendanceList) { item -&gt;&#10;                            // Check if it's archived&#10;                            if (archivedFromToday.any { it.id == item.documentId }) {&#10;                                Toast.makeText(requireContext(), &quot;Cannot modify archived attendance&quot;, Toast.LENGTH_SHORT).show()&#10;                            } else {&#10;                                confirmAndRemoveAttendance(item)&#10;                            }&#10;                        }&#10;                        attendanceRecyclerView.adapter = attendanceAdapter&#10;                        attendanceAdapter?.notifyDataSetChanged()&#10;                        &#10;                        // Scroll to top if new items were added&#10;                        if (newAttendanceList.size &gt; oldSize) {&#10;                            attendanceRecyclerView.smoothScrollToPosition(0)&#10;                        }&#10;                        &#10;                        val activeCount = activeSnapshot?.documents?.size ?: 0&#10;                        val archivedCount = archivedFromToday.size&#10;                        val label = if (archivedCount &gt; 0) &quot; ($activeCount active, $archivedCount archived)&quot; else &quot;&quot;&#10;                        textAttendanceCount.text = &quot;Total: ${attendanceList.size}$label&quot;&#10;                        &#10;                        android.util.Log.d(TAG, &quot;Loaded ${attendanceList.size} attendance records ($activeCount active, $archivedCount archived) with REAL-TIME updates&quot;)&#10;                    }&#10;                    .addOnFailureListener { archiveError -&gt;&#10;                        android.util.Log.e(TAG, &quot;Error loading archived attendance: ${archiveError.message}&quot;, archiveError)&#10;                        // Just show active attendance if archived query fails&#10;                        val sortedDocs = (activeSnapshot?.documents ?: emptyList())&#10;                            .sortedByDescending { it.getTimestamp(&quot;timestamp&quot;)?.seconds ?: 0 }&#10;                            .take(RECENT_ATTENDANCE_LIMIT)&#10;                        &#10;                        val newAttendanceList = sortedDocs.map { doc -&gt;&#10;                            TeacherAttendanceItem(&#10;                                documentId = doc.id,&#10;                                studentName = doc.getString(&quot;studentName&quot;) ?: &quot;Unknown Student&quot;,&#10;                                timeTaken = formatTimestamp(doc.getTimestamp(&quot;timestamp&quot;)),&#10;                                section = doc.getString(&quot;section&quot;) ?: &quot;&quot;,&#10;                                status = doc.getString(&quot;status&quot;) ?: &quot;PRESENT&quot;&#10;                            )&#10;                        }&#10;                        &#10;                        // Update the adapter's data&#10;                        attendanceList.clear()&#10;                        attendanceList.addAll(newAttendanceList)&#10;                        &#10;                        // Recreate adapter for consistency&#10;                        attendanceAdapter = TeacherAttendanceAdapter(attendanceList) { item -&gt;&#10;                            confirmAndRemoveAttendance(item)&#10;                        }&#10;                        attendanceRecyclerView.adapter = attendanceAdapter&#10;                        attendanceAdapter?.notifyDataSetChanged()&#10;                        textAttendanceCount.text = &quot;Total: ${attendanceList.size}&quot;&#10;                    }&#10;            }&#10;    }&#10;&#10;    private fun confirmAndRemoveAttendance(item: TeacherAttendanceItem) {&#10;        AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Remove attendance&quot;)&#10;            .setMessage(&quot;Remove ${item.studentName}'s attendance?&quot;)&#10;            .setPositiveButton(&quot;Remove&quot;) { _, _ -&gt;&#10;                val db = FirebaseFirestore.getInstance()&#10;                val attendanceId = item.documentId&#10;                &#10;                // First, get the attendance document to archive it&#10;                db.collection(&quot;attendance&quot;)&#10;                    .document(attendanceId)&#10;                    .get()&#10;                    .addOnSuccessListener { document -&gt;&#10;                        if (document.exists()) {&#10;                            // Archive the document for historical analytics&#10;                            val archiveData = document.data?.toMutableMap() ?: mutableMapOf()&#10;                            archiveData[&quot;archivedAt&quot;] = System.currentTimeMillis()&#10;                            archiveData[&quot;originalId&quot;] = attendanceId&#10;                            &#10;                            db.collection(&quot;archived_attendance&quot;)&#10;                                .document(attendanceId)&#10;                                .set(archiveData)&#10;                                .addOnSuccessListener {&#10;                                    // Now delete from the active collection&#10;                                    db.collection(&quot;attendance&quot;)&#10;                                        .document(attendanceId)&#10;                                        .delete()&#10;                                        .addOnSuccessListener {&#10;                                            Toast.makeText(requireContext(), &quot;Removed ${item.studentName}&quot;, Toast.LENGTH_SHORT).show()&#10;                                        }&#10;                                        .addOnFailureListener { ex -&gt;&#10;                                            Toast.makeText(requireContext(), &quot;Failed: ${ex.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                                        }&#10;                                }&#10;                                .addOnFailureListener { ex -&gt;&#10;                                    // Even if archiving fails, still try to delete&#10;                                    db.collection(&quot;attendance&quot;)&#10;                                        .document(attendanceId)&#10;                                        .delete()&#10;                                        .addOnSuccessListener {&#10;                                            Toast.makeText(requireContext(), &quot;Removed ${item.studentName}&quot;, Toast.LENGTH_SHORT).show()&#10;                                        }&#10;                                }&#10;                        }&#10;                    }&#10;                    .addOnFailureListener { ex -&gt;&#10;                        Toast.makeText(requireContext(), &quot;Failed: ${ex.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;, null)&#10;            .show()&#10;    }&#10;    &#10;    private fun getCurrentDayOfWeek(): String {&#10;        val calendar = java.util.Calendar.getInstance()&#10;        val dayFormat = java.text.SimpleDateFormat(&quot;EEEE&quot;, java.util.Locale.getDefault())&#10;        return dayFormat.format(calendar.time)&#10;    }&#10;    &#10;    private fun parseTimeToHour(timeString: String): Int {&#10;        return try {&#10;            val parts = timeString.split(&quot;:&quot;)&#10;            parts[0].toInt()&#10;        } catch (e: Exception) {&#10;            0&#10;        }&#10;    }&#10;    &#10;    private fun formatTimestamp(timestamp: com.google.firebase.Timestamp?): String {&#10;        return timestamp?.toDate()?.let { date -&gt;&#10;            val format = java.text.SimpleDateFormat(&quot;HH:mm&quot;, java.util.Locale.getDefault())&#10;            format.format(date)&#10;        } ?: &quot;&quot;&#10;    }&#10;    &#10;    private fun showManualAddDialog() {&#10;        val currentUser = auth.currentUser ?: return&#10;        val nowMinutes = getCurrentTimeInMinutes()&#10;        val currentDay = getCurrentDayOfWeek()&#10;        &#10;        db.collection(&quot;schedules&quot;)&#10;            .whereEqualTo(&quot;teacherId&quot;, currentUser.uid)&#10;            .whereEqualTo(&quot;day&quot;, currentDay)&#10;            .get()&#10;            .addOnSuccessListener { scheduleDocs -&gt;&#10;                val todays = scheduleDocs.documents&#10;                val currentSchedule = todays.firstOrNull { doc -&gt;&#10;                    val start = doc.getString(&quot;startTime&quot;) ?: &quot;&quot;&#10;                    val end = doc.getString(&quot;endTime&quot;) ?: &quot;&quot;&#10;                    isNowWithinRange(nowMinutes, start, end)&#10;                }&#10;&#10;                fun proceedWith(doc: com.google.firebase.firestore.DocumentSnapshot) {&#10;                    val subject = doc.getString(&quot;subject&quot;) ?: &quot;&quot;&#10;                    val section = doc.getString(&quot;section&quot;) ?: &quot;&quot;&#10;                    loadStudentsForSection(section, subject, doc.id)&#10;                }&#10;&#10;                if (currentSchedule != null) {&#10;                    proceedWith(currentSchedule)&#10;                } else if (todays.isNotEmpty()) {&#10;                    showSchedulePicker(todays, title = &quot;Select class for manual add&quot;) { chosen -&gt;&#10;                        proceedWith(chosen)&#10;                    }&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;No schedules found for today&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Toast.makeText(requireContext(), &quot;Error loading schedule: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;    }&#10;&#10;    private fun getCurrentTimeInMinutes(): Int {&#10;        val cal = java.util.Calendar.getInstance()&#10;        return cal.get(java.util.Calendar.HOUR_OF_DAY) * 60 + cal.get(java.util.Calendar.MINUTE)&#10;    }&#10;&#10;    private fun parseTimeToMinutes24(time: String): Int? {&#10;        return try {&#10;            val parts = time.split(&quot;:&quot;)&#10;            val hour = parts.getOrNull(0)?.toInt() ?: return null&#10;            val minute = parts.getOrNull(1)?.toInt() ?: 0&#10;            hour * 60 + minute&#10;        } catch (_: Exception) { null }&#10;    }&#10;&#10;    private fun isNowWithinRange(nowMinutes: Int, start: String, end: String): Boolean {&#10;        val s = parseTimeToMinutes24(start) ?: return false&#10;        val e = parseTimeToMinutes24(end) ?: return false&#10;        return if (e &lt; s) {&#10;            nowMinutes &gt;= s || nowMinutes &lt;= e&#10;        } else {&#10;            nowMinutes in s until e&#10;        }&#10;    }&#10;&#10;    private fun showSchedulePicker(&#10;        schedules: List&lt;com.google.firebase.firestore.DocumentSnapshot&gt;,&#10;        title: String,&#10;        onChosen: (com.google.firebase.firestore.DocumentSnapshot) -&gt; Unit&#10;    ) {&#10;        val items = schedules.map { doc -&gt;&#10;            val subject = doc.getString(&quot;subject&quot;) ?: &quot;&quot;&#10;            val section = doc.getString(&quot;section&quot;) ?: &quot;&quot;&#10;            val start = doc.getString(&quot;startTime&quot;) ?: &quot;&quot;&#10;            val end = doc.getString(&quot;endTime&quot;) ?: &quot;&quot;&#10;            &quot;$subject ($section)  $start-$end&quot;&#10;        }.toTypedArray()&#10;&#10;        android.app.AlertDialog.Builder(requireContext())&#10;            .setTitle(title)&#10;            .setItems(items) { dialog, which -&gt;&#10;                onChosen(schedules[which])&#10;                dialog.dismiss()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;, null)&#10;            .show()&#10;    }&#10;    &#10;    private fun loadStudentsForSection(section: String, subject: String, scheduleId: String) {&#10;        val target = section.trim().lowercase()&#10;        db.collection(&quot;users&quot;)&#10;            .whereEqualTo(&quot;role&quot;, &quot;student&quot;)&#10;            .get()&#10;            .addOnSuccessListener { studentDocs -&gt;&#10;                val students = studentDocs&#10;                    .filter { (it.getString(&quot;role&quot;) ?: &quot;&quot;) == &quot;student&quot; }&#10;                    .mapNotNull { doc -&gt;&#10;                        val studentSection = (doc.getString(&quot;section&quot;) ?: &quot;&quot;).trim().lowercase()&#10;                        if (studentSection == target) {&#10;                            StudentItem(&#10;                                id = doc.id,&#10;                                name = doc.getString(&quot;name&quot;) ?: &quot;Unknown Student&quot;,&#10;                                email = doc.getString(&quot;email&quot;) ?: &quot;&quot;,&#10;                                section = doc.getString(&quot;section&quot;) ?: &quot;&quot;&#10;                            )&#10;                        } else null&#10;                    }&#10;                &#10;                if (students.isNotEmpty()) {&#10;                    showStudentSelectionDialog(students, subject, scheduleId)&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;No students found in section $section&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Toast.makeText(requireContext(), &quot;Error loading students: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;    }&#10;    &#10;    private fun showStudentSelectionDialog(students: List&lt;StudentItem&gt;, subject: String, scheduleId: String) {&#10;        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_manual_add_student, null)&#10;        val dialog = AlertDialog.Builder(requireContext())&#10;            .setView(dialogView)&#10;            .create()&#10;        &#10;        val textCurrentSession = dialogView.findViewById&lt;TextView&gt;(R.id.textCurrentSession)&#10;        val radioPresent = dialogView.findViewById&lt;RadioButton&gt;(R.id.radioPresent)&#10;        val radioExcused = dialogView.findViewById&lt;RadioButton&gt;(R.id.radioExcused)&#10;        val radioAbsent = dialogView.findViewById&lt;RadioButton&gt;(R.id.radioAbsent)&#10;&#10;        // RadioGroup is defined in XML now; nothing needed here&#10;        val btnCancel = dialogView.findViewById&lt;Button&gt;(R.id.btnCancel)&#10;        val btnAddStudent = dialogView.findViewById&lt;Button&gt;(R.id.btnAddStudent)&#10;        &#10;        textCurrentSession.text = &quot;Current Session: $subject&quot;&#10;        &#10;        // Setup autocomplete for student names&#10;        val autoComplete = dialogView.findViewById&lt;AutoCompleteTextView&gt;(R.id.editStudentName)&#10;        val studentNames = students.map { it.name }&#10;        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_dropdown_item_1line, studentNames)&#10;        autoComplete.setAdapter(adapter)&#10;        &#10;        btnCancel.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;        &#10;        btnAddStudent.setOnClickListener {&#10;            val studentName = dialogView.findViewById&lt;AutoCompleteTextView&gt;(R.id.editStudentName).text.toString().trim()&#10;            &#10;            if (studentName.isEmpty()) {&#10;                Toast.makeText(requireContext(), &quot;Please enter a student name&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;            &#10;            // Get selected status&#10;            val status = when {&#10;                radioExcused.isChecked -&gt; &quot;EXCUSED&quot;&#10;                radioAbsent.isChecked -&gt; &quot;ABSENT&quot;&#10;                else -&gt; &quot;PRESENT&quot;&#10;            }&#10;            &#10;            // Find the student in our list&#10;            val selectedStudent = students.find { it.name.equals(studentName, ignoreCase = true) }&#10;            if (selectedStudent != null) {&#10;                addStudentsManually(listOf(selectedStudent), subject, scheduleId, status)&#10;                dialog.dismiss()&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;Student '$studentName' not found in current section&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;        &#10;        dialog.show()&#10;    }&#10;    &#10;    private fun addStudentsManually(students: List&lt;StudentItem&gt;, subject: String, scheduleId: String, status: String) {&#10;        val currentUser = auth.currentUser ?: return&#10;        val currentTime = com.google.firebase.Timestamp.now()&#10;        &#10;        android.util.Log.d(TAG, &quot;Manually adding ${students.size} students to attendance - Subject: $subject, Status: $status&quot;)&#10;        &#10;        students.forEach { student -&gt;&#10;            val attendanceData = hashMapOf(&#10;                &quot;userId&quot; to student.id,&#10;                &quot;studentName&quot; to student.name,&#10;                &quot;sessionId&quot; to &quot;MANUAL_${System.currentTimeMillis()}&quot;, // Unique session ID for manual entries&#10;                &quot;teacherId&quot; to currentUser.uid,&#10;                &quot;scheduleId&quot; to scheduleId,&#10;                &quot;subject&quot; to subject,&#10;                &quot;section&quot; to student.section,&#10;                &quot;timestamp&quot; to currentTime,&#10;                &quot;status&quot; to status,&#10;                &quot;location&quot; to &quot;&quot;,&#10;                &quot;notes&quot; to &quot;Manually added by teacher - Status: $status&quot;,&#10;                &quot;isManualEntry&quot; to true // Flag to identify manual entries&#10;            )&#10;            &#10;            android.util.Log.d(TAG, &quot;Adding manual attendance: ${student.name} - $subject (${student.section}) - $status&quot;)&#10;            &#10;            db.collection(&quot;attendance&quot;).add(attendanceData)&#10;                .addOnSuccessListener { docRef -&gt;&#10;                    android.util.Log.d(TAG, &quot;Successfully added manual attendance for ${student.name} with ID: ${docRef.id}&quot;)&#10;                    Toast.makeText(requireContext(), &quot;Added ${student.name} to attendance&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;                .addOnFailureListener { e -&gt;&#10;                    android.util.Log.e(TAG, &quot;Failed to add manual attendance for ${student.name}: ${e.message}&quot;, e)&#10;                    Toast.makeText(requireContext(), &quot;Failed to add ${student.name}: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;        }&#10;        // Ensure we are listening to updates for this schedule so the UI reflects changes instantly&#10;        startAttendanceListener(scheduleId, subject)&#10;    }&#10;&#10;    private fun confirmEndClass() {&#10;        AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;End Class&quot;)&#10;            .setMessage(&quot;This will archive all attendance from this class session. The attendance will be removed from Recent Attendance but kept for analytics. Continue?&quot;)&#10;            .setPositiveButton(&quot;End Class&quot;) { _, _ -&gt;&#10;                archiveCurrentClassAttendance()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;, null)&#10;            .show()&#10;    }&#10;    &#10;    private fun archiveCurrentClassAttendance() {&#10;        val scheduleId = listeningScheduleId ?: return&#10;        val subject = listeningSubject ?: return&#10;        val currentUser = auth.currentUser ?: return&#10;        &#10;        viewLifecycleOwner.lifecycleScope.launch {&#10;            try {&#10;                // Get all attendance records for the current class session&#10;                val attendanceSnapshot = db.collection(&quot;attendance&quot;)&#10;                    .whereEqualTo(&quot;teacherId&quot;, currentUser.uid)&#10;                    .whereEqualTo(&quot;scheduleId&quot;, scheduleId)&#10;                    .whereEqualTo(&quot;subject&quot;, subject)&#10;                    .get()&#10;                    .await()&#10;                &#10;                android.util.Log.d(TAG, &quot;Archiving ${attendanceSnapshot.size()} attendance records for $subject&quot;)&#10;                &#10;                var archivedCount = 0&#10;                // Archive each record&#10;                for (doc in attendanceSnapshot.documents) {&#10;                    val archiveData = doc.data?.toMutableMap() ?: continue&#10;                    archiveData[&quot;archivedAt&quot;] = System.currentTimeMillis()&#10;                    archiveData[&quot;originalId&quot;] = doc.id&#10;                    &#10;                    // Add to archived collection&#10;                    db.collection(&quot;archived_attendance&quot;)&#10;                        .document(doc.id)&#10;                        .set(archiveData)&#10;                        .await()&#10;                    &#10;                    // Delete from active collection&#10;                    doc.reference.delete().await()&#10;                    archivedCount++&#10;                }&#10;                &#10;                // Hide the End Class button&#10;                buttonEndClass.visibility = View.GONE&#10;                &#10;                // Clear the current listening state&#10;                attendanceListener?.remove()&#10;                listeningScheduleId = null&#10;                listeningSubject = null&#10;                &#10;                // Reload to show empty/next class&#10;                loadRecentAttendance()&#10;                &#10;                Toast.makeText(requireContext(), &quot;Class ended. $archivedCount records archived.&quot;, Toast.LENGTH_SHORT).show()&#10;                android.util.Log.d(TAG, &quot;Successfully archived $archivedCount attendance records&quot;)&#10;                &#10;            } catch (e: Exception) {&#10;                android.util.Log.e(TAG, &quot;Error archiving attendance: ${e.message}&quot;, e)&#10;                Toast.makeText(requireContext(), &quot;Error archiving attendance: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun archiveEndedClassesAttendance(endedSchedules: List&lt;com.google.firebase.firestore.DocumentSnapshot&gt;) {&#10;        val currentUser = auth.currentUser ?: return&#10;        &#10;        viewLifecycleOwner.lifecycleScope.launch {&#10;            try {&#10;                var totalArchived = 0&#10;                &#10;                for (schedule in endedSchedules) {&#10;                    val scheduleId = schedule.id&#10;                    val subject = schedule.getString(&quot;subject&quot;) ?: continue&#10;                    &#10;                    // Get attendance records for this ended class from today&#10;                    val calendar = java.util.Calendar.getInstance()&#10;                    calendar.set(java.util.Calendar.HOUR_OF_DAY, 0)&#10;                    calendar.set(java.util.Calendar.MINUTE, 0)&#10;                    calendar.set(java.util.Calendar.SECOND, 0)&#10;                    calendar.set(java.util.Calendar.MILLISECOND, 0)&#10;                    val todayStart = com.google.firebase.Timestamp(calendar.time)&#10;                    &#10;                    val attendanceSnapshot = db.collection(&quot;attendance&quot;)&#10;                        .whereEqualTo(&quot;teacherId&quot;, currentUser.uid)&#10;                        .whereEqualTo(&quot;scheduleId&quot;, scheduleId)&#10;                        .whereEqualTo(&quot;subject&quot;, subject)&#10;                        .whereGreaterThanOrEqualTo(&quot;timestamp&quot;, todayStart)&#10;                        .get()&#10;                        .await()&#10;                    &#10;                    // Archive each record&#10;                    for (doc in attendanceSnapshot.documents) {&#10;                        val archiveData = doc.data?.toMutableMap() ?: continue&#10;                        archiveData[&quot;archivedAt&quot;] = System.currentTimeMillis()&#10;                        archiveData[&quot;originalId&quot;] = doc.id&#10;                        archiveData[&quot;autoArchived&quot;] = true&#10;                        &#10;                        // Add to archived collection&#10;                        db.collection(&quot;archived_attendance&quot;)&#10;                            .document(doc.id)&#10;                            .set(archiveData)&#10;                            .await()&#10;                        &#10;                        // Delete from active collection&#10;                        doc.reference.delete().await()&#10;                        totalArchived++&#10;                    }&#10;                    &#10;                    android.util.Log.d(TAG, &quot;Auto-archived ${attendanceSnapshot.size()} records from ended class: $subject&quot;)&#10;                }&#10;                &#10;                if (totalArchived &gt; 0) {&#10;                    android.util.Log.d(TAG, &quot;Auto-archived total of $totalArchived attendance records from ${endedSchedules.size} ended classes&quot;)&#10;                }&#10;                &#10;            } catch (e: Exception) {&#10;                android.util.Log.e(TAG, &quot;Error auto-archiving ended classes: ${e.message}&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun scheduleAutoArchiveAtClassEnd(endTime: String) {&#10;        // Cancel any existing scheduled archiving&#10;        classEndRunnable?.let { classEndHandler.removeCallbacks(it) }&#10;        &#10;        try {&#10;            // Calculate milliseconds until class ends&#10;            val (endHour, endMin) = parseTime24(endTime)&#10;            val now = java.util.Calendar.getInstance()&#10;            val classEnd = java.util.Calendar.getInstance().apply {&#10;                set(java.util.Calendar.HOUR_OF_DAY, endHour)&#10;                set(java.util.Calendar.MINUTE, endMin)&#10;                set(java.util.Calendar.SECOND, 0)&#10;                set(java.util.Calendar.MILLISECOND, 0)&#10;            }&#10;            &#10;            val millisUntilEnd = classEnd.timeInMillis - now.timeInMillis&#10;            &#10;            if (millisUntilEnd &gt; 0) {&#10;                classEndRunnable = Runnable {&#10;                    android.util.Log.d(TAG, &quot;Class end time reached - auto-archiving attendance&quot;)&#10;                    archiveCurrentClassAttendance()&#10;                }&#10;                classEndHandler.postDelayed(classEndRunnable!!, millisUntilEnd)&#10;                android.util.Log.d(TAG, &quot;Scheduled auto-archive in ${millisUntilEnd / 1000 / 60} minutes at $endTime&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(TAG, &quot;Error scheduling auto-archive: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        attendanceListener?.remove()&#10;        attendanceListener = null&#10;        listeningScheduleId = null&#10;        listeningSubject = null&#10;        attendanceAdapter = null&#10;        attendanceList.clear()&#10;        classEndRunnable?.let { classEndHandler.removeCallbacks(it) }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>